// src/hooks/useWorkoutCalculations.js
// ‚ö° WA-013.3: Hook de calculs optimis√©s avec useMemo
// R√©f√©rence Clean Code: "Functions should do one thing" - Calculs purs s√©par√©s
// R√©f√©rence Pragmatic Programmer: "Optimize when it matters" - Performance cibl√©e

import { useMemo, useRef, useCallback } from 'react';
import { EXERCISES_DATABASE } from '../data/exercices.js';
import { DIFFICULTY_LEVELS } from '../data/workoutPresets.js';
import { formatDuration,
        calculateTimeComplexity,
        calculateVolumeComplexity,
        calculateExerciseComplexity,
        getDifficultyLabel,
        getIntensityLevel,
        getNextLevelTarget,
        identifyImprovementAreas,
        generateMuscleRecommendations,
        generateProgressionSuggestions,
        calculateDiversityIndex,
        analyzeExerciseSequence,
        generateOptimalSequence,
        calculateProjections,
        calculateSustainabilityScore,
        generateOptimizationSuggestions,
        benchmarkCalculation,
        CalculationCache,
        globalCalculationCache
} from '../utils/calculationUtils.js';

/**
 * üéØ Constantes pour calculs de performance
 */
const CALORIES_PER_MINUTE = {
  'd√©butant': 6,      // 6 calories/minute
  'interm√©diaire': 8, // 8 calories/minute
  'avanc√©': 12        // 12 calories/minute
};

const INTENSITY_MULTIPLIERS = {
  'cardio': 1.3,
  'strength': 1.0,
  'hiit': 1.5,
  'recovery': 0.6
};

const MUSCLE_GROUP_COLORS = {
  'pectoraux': '#ff6b6b',
  'dos': '#4ecdc4', 
  'jambes': '#45b7d1',
  'bras': '#96ceb4',
  'abdos': '#feca57',
  '√©paules': '#ff9ff3',
  'cardio': '#fd79a8'
};

/**
 * üèóÔ∏è Hook useWorkoutCalculations - Calculs optimis√©s avec useMemo
 * 
 * Ce hook centralise TOUS les calculs co√ªteux :
 * - Dur√©e totale et par phase
 * - Calories estim√©es avec pr√©cision
 * - Analyse des groupes musculaires
 * - Statistiques de difficult√©
 * - M√©triques de performance
 * 
 * Clean Code: "Single Responsibility" - Seulement les CALCULS
 * Pragmatic Programmer: "Optimize when it matters" - useMemo cibl√©
 * 
 * @param {Object} configState - √âtat de configuration
 * @returns {Object} Tous les calculs m√©moris√©s
 */
export const useWorkoutCalculations = (configState) => {
  // üîó Cache pour √©viter recalculs identiques
  const calculationCache = useRef(new Map());
  const lastStateHash = useRef('');

  // üéØ Hash de l'√©tat pour d√©tection changements
  const stateHash = useMemo(() => {
    const relevantState = {
      workTime: configState.workTime,
      restTime: configState.restTime,
      prepTime: configState.prepTime,
      rounds: configState.rounds,
      exercises: configState.exercises,
      difficulty: configState.difficulty
    };
    return btoa(JSON.stringify(relevantState)).slice(0, 12);
  }, [configState.workTime, configState.restTime, configState.prepTime, 
      configState.rounds, configState.exercises, configState.difficulty]);

  // ‚è±Ô∏è Calculs de dur√©e optimis√©s avec useMemo
  const durationCalculations = useMemo(() => {
    console.log('üßÆ Calcul dur√©es - useMemo d√©clench√© - useWorkoutCalculations.js ');
    
    const { workTime, restTime, prepTime, rounds, exercises } = configState;
    
    if (exercises.length === 0) {
      return {
        totalSeconds: 0,
        totalMinutes: 0,
        workSeconds: 0,
        restSeconds: 0,
        prepSeconds: prepTime,
        roundDuration: 0,
        averageExerciseTime: 0,
        formattedDuration: '0:00'
      };
    }

    // Calculs de base
    const workSeconds = exercises.length * workTime * rounds;
    const restSeconds = exercises.length * restTime * rounds;
    const totalSeconds = workSeconds + restSeconds + prepTime;
    const roundDuration = exercises.length * (workTime + restTime);
    
    return {
      totalSeconds,
      totalMinutes: Math.ceil(totalSeconds / 60),
      workSeconds,
      restSeconds,
      prepSeconds: prepTime,
      roundDuration,
      averageExerciseTime: workTime + restTime,
      formattedDuration: formatDuration(totalSeconds),
      
      // M√©triques avanc√©es
      workPercentage: Math.round((workSeconds / totalSeconds) * 100),
      restPercentage: Math.round((restSeconds / totalSeconds) * 100),
      intensityRatio: workTime / (workTime + restTime),
      totalExerciseCount: exercises.length * rounds
    };
  }, [configState.workTime, configState.restTime, configState.prepTime, 
      configState.rounds, configState.exercises]);

  // üî• Calculs de calories optimis√©s
  const calorieCalculations = useMemo(() => {
    console.log('üî• Calcul calories - useMemo d√©clench√©');
    
    const { difficulty, exercises } = configState;
    const { totalMinutes, intensityRatio } = durationCalculations;
    
    if (totalMinutes === 0) {
      return {
        estimatedCalories: 0,
        caloriesPerMinute: 0,
        calorieRange: { min: 0, max: 0 },
        burnRate: 'faible'
      };
    }

    // Calcul base selon difficult√©
    const baseCaloriesPerMin = CALORIES_PER_MINUTE[difficulty] || CALORIES_PER_MINUTE.d√©butant;
    
    // Analyse des types d'exercices pour ajustement
    const exerciseTypes = exercises.map(id => EXERCISES_DATABASE[id]?.type || 'strength');
    const typeMultipliers = exerciseTypes.map(type => INTENSITY_MULTIPLIERS[type] || 1.0);
    const avgMultiplier = typeMultipliers.reduce((sum, mult) => sum + mult, 0) / typeMultipliers.length;
    
    // Ajustement selon ratio intensit√©
    const intensityAdjustment = 0.7 + (intensityRatio * 0.6); // 0.7 √† 1.3
    
    // Calcul final
    const caloriesPerMinute = baseCaloriesPerMin * avgMultiplier * intensityAdjustment;
    const estimatedCalories = Math.round(caloriesPerMinute * totalMinutes);
    
    // Range d'estimation (¬±20%)
    const calorieRange = {
      min: Math.round(estimatedCalories * 0.8),
      max: Math.round(estimatedCalories * 1.2)
    };
    
    // Classification du taux de combustion
    let burnRate = 'faible';
    if (caloriesPerMinute >= 10) burnRate = '√©lev√©';
    else if (caloriesPerMinute >= 7) burnRate = 'mod√©r√©';
    
    return {
      estimatedCalories,
      caloriesPerMinute: Math.round(caloriesPerMinute * 10) / 10,
      calorieRange,
      burnRate,
      intensityScore: Math.round(intensityRatio * 100),
      metabolicEquivalence: Math.round((caloriesPerMinute / 5) * 10) / 10 // METs approximatifs
    };
  }, [configState.difficulty, configState.exercises, durationCalculations]);

  // üèãÔ∏è‚Äç‚ôÄÔ∏è Analyse des groupes musculaires optimis√©e
  const muscleGroupAnalysis = useMemo(() => {
    console.log('üí™ Analyse groupes musculaires - useMemo d√©clench√©');
    
    const { exercises } = configState;
    
    if (exercises.length === 0) {
      return {
        targetedGroups: [],
        muscleDistribution: {},
        dominantGroup: null,
        coverage: 0,
        balanceScore: 0,
        recommendations: []
      };
    }

    // Collecte des groupes musculaires avec fr√©quence
    const muscleCount = {};
    const muscleDetails = [];
    
    exercises.forEach((exerciseId, index) => {
      const exercise = EXERCISES_DATABASE[exerciseId];
      if (exercise) {
        const group = exercise.muscleGroup;
        muscleCount[group] = (muscleCount[group] || 0) + 1;
        muscleDetails.push({
          exerciseId,
          name: exercise.name,
          muscleGroup: group,
          position: index,
          color: MUSCLE_GROUP_COLORS[group] || '#95a5a6'
        });
      }
    });

    // Calculs de distribution
    const totalExercises = exercises.length;
    const muscleDistribution = {};
    Object.entries(muscleCount).forEach(([group, count]) => {
      muscleDistribution[group] = {
        count,
        percentage: Math.round((count / totalExercises) * 100),
        color: MUSCLE_GROUP_COLORS[group] || '#95a5a6'
      };
    });

    // Groupe dominant
    const dominantGroup = Object.entries(muscleCount)
      .reduce((max, [group, count]) => count > max.count ? { group, count } : max, 
              { group: null, count: 0 });

    // Score de couverture (nombre de groupes diff√©rents)
    const uniqueGroups = Object.keys(muscleCount);
    const maxPossibleGroups = Object.keys(MUSCLE_GROUP_COLORS).length;
    const coverage = Math.round((uniqueGroups.length / maxPossibleGroups) * 100);

    // Score d'√©quilibre (√©viter concentration sur un seul groupe)
    const balanceScore = uniqueGroups.length > 1 
      ? Math.round(100 - (dominantGroup.count / totalExercises * 100))
      : 0;

    // Recommandations intelligentes
    const recommendations = generateMuscleRecommendations(
      muscleDistribution, 
      dominantGroup, 
      coverage
    );

    return {
      targetedGroups: uniqueGroups,
      muscleDistribution,
      dominantGroup: dominantGroup.group,
      dominantPercentage: Math.round((dominantGroup.count / totalExercises) * 100),
      coverage,
      balanceScore,
      muscleDetails,
      recommendations,
      
      // M√©triques avanc√©es
      diversityIndex: calculateDiversityIndex(muscleCount),
      sequenceAnalysis: analyzeExerciseSequence(muscleDetails)
    };
  }, [configState.exercises]);

  // üìä Analyse de difficult√© et progression optimis√©e
  const difficultyAnalysis = useMemo(() => {
    console.log('üéØ Analyse difficult√© - useMemo d√©clench√©');
    
    const { difficulty, workTime, restTime, rounds, exercises } = configState;
    const { intensityRatio } = durationCalculations;
    
    // M√©triques de difficult√© par composant
    const timeComplexity = calculateTimeComplexity(workTime, restTime, intensityRatio);
    const volumeComplexity = calculateVolumeComplexity(exercises.length, rounds);
    const exerciseComplexity = calculateExerciseComplexity(exercises);
    
    // Score de difficult√© global (0-100)
    const difficultyScore = Math.round(
      (timeComplexity * 0.4) + 
      (volumeComplexity * 0.3) + 
      (exerciseComplexity * 0.3)
    );

    // Comparaison avec niveau d√©clar√©
    const expectedDifficulty = {
      'd√©butant': { min: 0, max: 35 },
      'interm√©diaire': { min: 30, max: 70 },
      'avanc√©': { min: 65, max: 100 }
    };

    const currentLevel = expectedDifficulty[difficulty];
    const isAligned = difficultyScore >= currentLevel.min && difficultyScore <= currentLevel.max;
    
    // Suggestions de progression
    const progressionSuggestions = generateProgressionSuggestions(
      difficulty, 
      difficultyScore, 
      configState
    );

    return {
      difficultyScore,
      timeComplexity,
      volumeComplexity,
      exerciseComplexity,
      isAligned,
      currentLevel,
      progressionSuggestions,
      
      // Classification textuelle
      difficultyLabel: getDifficultyLabel(difficultyScore),
      intensityLevel: getIntensityLevel(intensityRatio),

      // M√©triques de progression
      nextLevelScore: getNextLevelTarget(difficulty, difficultyScore),
      improvementAreas: identifyImprovementAreas(timeComplexity, volumeComplexity, exerciseComplexity)
    };
  }, [configState.difficulty, configState.workTime, configState.restTime, 
      configState.rounds, configState.exercises, durationCalculations]);

  // üìà M√©triques de performance globales optimis√©es
  const performanceMetrics = useMemo(() => {
    console.log('üìà Calcul m√©triques performance - useMemo d√©clench√©');
    
    const { totalMinutes, intensityRatio } = durationCalculations;
    const { estimatedCalories, caloriesPerMinute } = calorieCalculations;
    const { coverage, balanceScore } = muscleGroupAnalysis;
    const { difficultyScore, isAligned } = difficultyAnalysis;
    
    // Score de qualit√© global (0-100)
    const qualityScore = Math.round(
      (coverage * 0.25) +           // Couverture musculaire
      (balanceScore * 0.25) +       // √âquilibre exercices
      (difficultyScore * 0.25) +    // Appropriation difficult√©
      ((isAligned ? 100 : 50) * 0.25) // Coh√©rence niveau
    );

    // Efficacit√© temporelle (calories/minute)
    const timeEfficiency = totalMinutes > 0 ? caloriesPerMinute : 0;
    
    // Score d'intensit√© (0-100)
    const intensityScore = Math.round(intensityRatio * 100);
    
    // Classification globale
    let overallRating = '√Ä am√©liorer';
    if (qualityScore >= 80) overallRating = 'Excellent';
    else if (qualityScore >= 65) overallRating = 'Tr√®s bon';
    else if (qualityScore >= 50) overallRating = 'Bon';
    
    // Pr√©dictions et projections
    const projections = calculateProjections(
      estimatedCalories, 
      totalMinutes, 
      intensityScore
    );

    return {
      qualityScore,
      timeEfficiency,
      intensityScore,
      overallRating,
      projections,
      
      // Scores d√©taill√©s
      scores: {
        muscleCoverage: coverage,
        balance: balanceScore,
        difficulty: difficultyScore,
        alignment: isAligned ? 100 : 50,
        efficiency: Math.min(timeEfficiency * 10, 100)
      },
      
      // Recommandations d'optimisation
      optimizationSuggestions: generateOptimizationSuggestions(
        qualityScore, 
        coverage, 
        balanceScore, 
        intensityScore
      )
    };
  }, [durationCalculations, calorieCalculations, muscleGroupAnalysis, difficultyAnalysis]);

  // üîÑ Fonction de nettoyage du cache
  const clearCalculationCache = useCallback(() => {
    calculationCache.current.clear();
    console.log('üßπ Cache de calculs nettoy√©');
  }, []);

  // üìä Fonction de benchmark des performances
  const benchmarkCalculations = useCallback(() => {
    const start = performance.now();
    
    // Force le recalcul de tous les useMemo
    const hash = Date.now().toString();
    
    const end = performance.now();
    const duration = end - start;
    
    console.log(`‚ö° Benchmark calculs: ${duration.toFixed(2)}ms`);
    return { duration, timestamp: start };
  }, []);

  // üèóÔ∏è Interface publique du hook
  return {
    // Calculs principaux
    durationCalculations,
    calorieCalculations,
    muscleGroupAnalysis,
    difficultyAnalysis,
    performanceMetrics,
    
    // M√©tadonn√©es
    stateHash,
    lastCalculation: Date.now(),
    
    // Utilitaires
    clearCalculationCache,
    benchmarkCalculations,
    
    // Getters optimis√©s pour composants
    getTotalDuration: useCallback(() => durationCalculations.formattedDuration, [durationCalculations]),
    getCalorieEstimate: useCallback(() => calorieCalculations.estimatedCalories, [calorieCalculations]),
    getMuscleGroups: useCallback(() => muscleGroupAnalysis.targetedGroups, [muscleGroupAnalysis]),
    getQualityScore: useCallback(() => performanceMetrics.qualityScore, [performanceMetrics]),
    
    // Validations rapides
    isWorkoutViable: useCallback(() => {
      return durationCalculations.totalMinutes > 0 && 
             muscleGroupAnalysis.targetedGroups.length > 0 &&
             performanceMetrics.qualityScore >= 30;
    }, [durationCalculations, muscleGroupAnalysis, performanceMetrics])
  };
};